<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Royale - Tower Defense</title>
    <style>
        :root {
            --primary: #3498db;
            --danger: #e74c3c;
            --elixir: #d35400;
            --card-bg: #ecf0f1;
        }

        body {
            margin: 0;
            background: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        /* Oyun Alanƒ± Konteynƒ±rƒ± */
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 4px solid #34495e;
            border-radius: 8px;
        }

        canvas {
            display: block;
            background: #27ae60; /* Arena √áimi */
            cursor: crosshair;
        }

        /* Alt Panel: Kartlar ve ƒ∞ksir */
        #ui-panel {
            width: 100%;
            background: #34495e;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #cards {
            display: flex;
            gap: 15px;
        }

        .card {
            width: 80px;
            height: 110px;
            background: var(--card-bg);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
            border: 3px solid transparent;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .card.selected {
            border-color: #f1c40f;
            box-shadow: 0 0 15px #f1c40f;
        }

        .card.disabled {
            filter: grayscale(1) opacity(0.6);
            cursor: not-allowed;
        }

        .card .cost {
            background: var(--elixir);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
            top: -10px;
            right: -10px;
        }

        .card .icon { font-size: 30px; margin-top: 15px; }
        .card .name { font-size: 12px; font-weight: bold; margin-bottom: 5px; }

        /* ƒ∞ksir Barƒ± */
        #elixir-container {
            width: 300px;
            height: 20px;
            background: #2c3e50;
            border-radius: 10px;
            border: 2px solid #bdc3c7;
            overflow: hidden;
        }

        #elixir-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #9b59b6, #8e44ad);
            transition: width 0.1s linear;
        }

        #elixir-text {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="400" height="600"></canvas>
</div>

<div id="ui-panel">
    <div id="elixir-text">ƒ∞ksir: 0</div>
    <div id="elixir-container">
        <div id="elixir-bar"></div>
    </div>
    <div id="cards">
        <div class="card" onclick="selectCard(0, this)" data-cost="3">
            <div class="cost">3</div>
            <div class="icon">üõ°Ô∏è</div>
            <div class="name">≈û√∂valye</div>
        </div>
        <div class="card" onclick="selectCard(1, this)" data-cost="2">
            <div class="cost">2</div>
            <div class="icon">üèπ</div>
            <div class="name">Ok√ßu</div>
        </div>
        <div class="card" onclick="selectCard(2, this)" data-cost="5">
            <div class="cost">5</div>
            <div class="icon">üëπ</div>
            <div class="name">Dev</div>
        </div>
    </div>
</div>

<script>
/**
 * OYUN MANTIƒûI VE AYARLARI
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const elixirBar = document.getElementById('elixir-bar');
const elixirText = document.getElementById('elixir-text');

let elixir = 5;
let maxElixir = 10;
let selectedCardIndex = null;
let shakeTime = 0;

// Birim Tipleri Veritabanƒ±
const unitTypes = [
    { name: '≈û√∂valye', hp: 100, damage: 15, range: 20, speed: 1.2, color: '#3498db', cost: 3, icon: 'üõ°Ô∏è' },
    { name: 'Ok√ßu', hp: 50, damage: 10, range: 100, speed: 1.5, color: '#f1c40f', cost: 2, icon: 'üèπ' },
    { name: 'Dev', hp: 300, damage: 20, range: 25, speed: 0.6, color: '#e67e22', cost: 5, icon: 'üëπ' }
];

let units = []; // Sahadaki t√ºm askerler
let towers = []; // Kuleler

/**
 * KULE SINIFI
 */
class Tower {
    constructor(x, y, owner) {
        this.x = x;
        this.y = y;
        this.owner = owner; // 'player' veya 'enemy'
        this.hp = 500;
        this.maxHp = 500;
        this.size = 40;
    }

    draw() {
        ctx.fillStyle = this.owner === 'player' ? '#2980b9' : '#c0392b';
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        
        // Can Barƒ±
        this.drawHealthBar();
    }

    drawHealthBar() {
        const barWidth = 50;
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - barWidth/2, this.y - 35, barWidth, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x - barWidth/2, this.y - 35, (this.hp / this.maxHp) * barWidth, 5);
    }
}

/**
 * ASKER SINIFI
 */
class Unit {
    constructor(typeIndex, x, y, owner) {
        const type = unitTypes[typeIndex];
        this.typeIndex = typeIndex;
        this.x = x;
        this.y = y;
        this.owner = owner;
        this.hp = type.hp;
        this.maxHp = type.hp;
        this.damage = type.damage;
        this.range = type.range;
        this.speed = type.speed;
        this.color = type.color;
        this.icon = type.icon;
        this.target = null;
        this.lastAttack = 0;
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.stroke();
        
        // Simge
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.icon, this.x, this.y + 5);

        // K√º√ß√ºk Can Barƒ±
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 10, this.y - 20, 20, 3);
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x - 10, this.y - 20, (this.hp / this.maxHp) * 20, 3);
    }

    update() {
        this.findTarget();
        if (this.target) {
            const dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
            
            // Eƒüer menzildeyse saldƒ±r, deƒüilse ilerle
            if (dist > this.range) {
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            } else {
                this.attack();
            }
        }
    }

    // EN YAKIN HEDEF BULMA ALGORƒ∞TMASI (Sunumda bahsedilecek kƒ±sƒ±m)
    findTarget() {
        let potentialTargets = [];
        
        // D√º≈üman kulelerini ve askerlerini listele
        if (this.owner === 'player') {
            potentialTargets = [...units.filter(u => u.owner === 'enemy'), ...towers.filter(t => t.owner === 'enemy')];
        } else {
            potentialTargets = [...units.filter(u => u.owner === 'player'), ...towers.filter(t => t.owner === 'player')];
        }

        // En yakƒ±ndakini se√ß (Mesafe form√ºl√º: Hipoten√ºs)
        let minDistance = Infinity;
        let closest = null;

        potentialTargets.forEach(t => {
            const d = Math.hypot(t.x - this.x, t.y - this.y);
            if (d < minDistance) {
                minDistance = d;
                closest = t;
            }
        });
        this.target = closest;
    }

    attack() {
        const now = Date.now();
        if (now - this.lastAttack > 1000) { // Saniyede 1 vuru≈ü
            this.target.hp -= this.damage;
            this.lastAttack = now;
            
            // G√∂rsel efekt (vuru≈ü parlamasƒ±)
            createFlash(this.target.x, this.target.y);
            
            // Kule vurulduysa ekran sarsƒ±ntƒ±sƒ±
            if (this.target instanceof Tower) shakeTime = 10;
        }
    }
}

// G√∂rsel Efekt Listesi
let flashes = [];
function createFlash(x, y) {
    flashes.push({x, y, life: 10});
}

/**
 * BA≈ûLANGI√á KURULUMU
 */
function init() {
    // Oyuncu Kuleleri
    towers.push(new Tower(100, 520, 'player'));
    towers.push(new Tower(300, 520, 'player'));
    towers.push(new Tower(200, 560, 'player')); // Ana kule

    // Rakip Kuleleri
    towers.push(new Tower(100, 80, 'enemy'));
    towers.push(new Tower(300, 80, 'enemy'));
    towers.push(new Tower(200, 40, 'enemy'));
}

/**
 * KONTROLLER
 */
function selectCard(index, el) {
    const cost = unitTypes[index].cost;
    if (elixir >= cost) {
        selectedCardIndex = index;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }
}

canvas.addEventListener('mousedown', (e) => {
    if (selectedCardIndex === null) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Sadece kendi yarƒ± sahasƒ±na koyabilir (y > 300)
    if (y > 300 && elixir >= unitTypes[selectedCardIndex].cost) {
        units.push(new Unit(selectedCardIndex, x, y, 'player'));
        elixir -= unitTypes[selectedCardIndex].cost;
        selectedCardIndex = null;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
    }
});

/**
 * YAPAY ZEKA (Basit Rakip)
 */
function enemyAI() {
    if (Math.random() < 0.01) { // Periyodik asker g√∂nderimi
        const typeIdx = Math.floor(Math.random() * 3);
        const spawnX = 50 + Math.random() * 300;
        units.push(new Unit(typeIdx, spawnX, 100, 'enemy'));
    }
}

/**
 * OYUN D√ñNG√úS√ú (LOOP)
 */
function gameLoop() {
    // Ekran Sarsƒ±ntƒ±sƒ± (Screenshake)
    ctx.save();
    if (shakeTime > 0) {
        ctx.translate(Math.random()*5 - 2.5, Math.random()*5 - 2.5);
        shakeTime--;
    }

    // Temizlik
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Saha Ortasƒ± √áizgisi
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(0, 300); ctx.lineTo(400, 300);
    ctx.stroke();
    ctx.setLineDash([]);

    // ƒ∞ksir G√ºncelleme
    if (elixir < maxElixir) elixir += 0.01;
    elixirBar.style.width = (elixir / maxElixir) * 100 + '%';
    elixirText.innerText = `ƒ∞ksir: ${Math.floor(elixir)}`;

    // Kuleleri ve Birimleri √áiz/G√ºncelle
    towers = towers.filter(t => t.hp > 0);
    towers.forEach(t => t.draw());

    units.forEach((u, index) => {
        u.update();
        u.draw();
        if (u.hp <= 0) units.splice(index, 1);
    });

    // Parlama Efektleri
    flashes.forEach((f, i) => {
        ctx.fillStyle = `rgba(255, 255, 255, ${f.life/10})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, 15, 0, Math.PI*2);
        ctx.fill();
        f.life--;
        if (f.life <= 0) flashes.splice(i, 1);
    });

    // Kartlarƒ±n kullanƒ±labilirlik durumu
    document.querySelectorAll('.card').forEach((c, i) => {
        if (unitTypes[i].cost > elixir) c.classList.add('disabled');
        else c.classList.remove('disabled');
    });

    enemyAI();
    ctx.restore();
    requestAnimationFrame(gameLoop);
}

init();
gameLoop();
</script>
</body>
</html>
